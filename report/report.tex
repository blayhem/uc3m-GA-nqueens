\documentclass[12pt]{article}
\usepackage{makeidx}
\usepackage[margin=1in]{geometry}  % set the margins to 1in on all sides
\usepackage{graphicx}              % to include figures
\usepackage{amsmath}               % great math stuff
\usepackage{amsfonts}              % for blackboard bold, etc
\usepackage{amsthm}                % better theorem environments
\usepackage{makeidx}               % index
\usepackage[utf8]{inputenc}        % now we have tildes!
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage[spanish]{babel}
\usepackage{wrapfig}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{titletoc}
\usepackage{tocbibind}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage[T1]{fontenc}
\usepackage[many]{tcolorbox}
\usepackage{forloop}
\tcbuselibrary{listings}

% various theorems, numbered by section

\graphicspath{{static/}}

\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page

%----------------------------------------------------------------------------------------
% HEADING SECTIONS
%----------------------------------------------------------------------------------------

% \textsc{\LARGE Universidad Carlos III de Madrid}\\[1cm] % Name of your university/college

%----------------------------------------------------------------------------------------
% LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics[width=100mm]{uc3m_logo}\\[1cm] % Include a department/university logo - this will require the graphicx package

\textsc{\Large Algoritmos Genéticos y Evolutivos}\\[0.5cm] % Major heading such as course name
% \textsc{\large Grupo 84}\\[2cm] % Minor heading such as course title

%----------------------------------------------------------------------------------------
% TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries Práctica 1: N Reinas.}\\[0.4cm] % Title of your document
\HRule \\[2cm]

%----------------------------------------------------------------------------------------
% AUTHOR SECTION
%----------------------------------------------------------------------------------------
\vspace{6cm}

% If you don't want a supervisor, uncomment the two lines below and remove the section above
\emph{Autor:}\\[0.7cm]

\begin{tabular}{rl}
    Daniel \textsc{Fernández}: &\texttt{daniel.f.rico@alumnos.uc3m.es}
\end{tabular}\\[2cm]


%----------------------------------------------------------------------------------------
% DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[3cm] % Date, change the \today to a set date if you want to be precise
%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}

\tableofcontents

\newpage

\section{Contexto.}

\subsection{Problema de las 8 reinas.}

El problema de las ocho reinas es un problema clásico en computación y matemáticas, el cual consiste en colocar ocho reinas en un tablero de ajedrez (de 8 casillas) sin que se amenacen entre sí (en ajedrez, las reinas pueden moverse tantas casillas como quieran en cualquier dirección).
 
El problema original data de 1848 y fue propuesto por el ajedrecista Max Bezzel. Durante años, muchos matemáticos (incluyendo a Gauss), han trabajado en él y lo han generalizado a N-reinas. 
Las primeras soluciones se plantean en 1850.

Edsger Dijkstra usó este problema en 1972 para ilustrar el poder de la llamada programación estructurada. Publicó una descripción muy detallada del desarrollo del algoritmo de backtracking, "depth-first".

Para nuestro problema, tomaremos un enfoque más abstracto: dado un tablero de dimensiones $NxN$, queremos colocar $N$ reinas sin que se ataquen entre ellas.


\subsection{Problema planteado.}
Se plantea resolver el problema de las N-reinas para un valor de $N$ muy inferior a 1000 sin necesidad de hallar todas las soluciones, mediante la utilización de un Algoritmo Genético.

Primero afrontaremos el problema mediante un algoritmo de fuerza bruta con backtracking, para estudiar cuánto tarda en hallar posibles soluciones dentro del espacio de búsqueda.

A continuación, se implementa un Algoritmo Genético con el fin de hallar las soluciones para valores de $N$ computacionalmente intensos.

\section{Solucionar las N-reinas empleando fuerza bruta.}

\subsection{¿Cuánto se tarda en obtener la primera solución?}

\subsection{¿Cuánto se tardan en obtener soluciones subsecuentes?}

\section{Solucionar las N-reinas con Algoritmos Genéticos.}

\subsection{Codificación.}

La codificación actual para nuestro problema trata de un vector de tamaño $N$, donde cada valor corresponde a la posición $x$ de una reina sobre la fila $y$ del tablero, siendo $y$ el índice del elemento $x$ en el vector de reinas.

\subsubsection{¿Qué otras alternativas se han barajado y descartado?}

En primer lugar, se planteó una codificación del tablero como vector binario de tamaño $NxN$, de tal modo que cada individuo de la población fuese un vector de 0s y 1s, donde un 1 equivale a una reina en la posición equivalente del tablero, y un 0 la ausencia de ésta.

En segundo lugar, se planteó un vector de reinas de tamaño $N$, donde sólo se acumulasen las reinas que se encontraban en el tablero. Dicho vector estaría compuesto de tuplas $(x,y)$ correspondientes a la posición de cada reina en el tablero.

Al darnos cuenta de que los números $x$ e $y$ han de ser excluyentes (restricción para evitar ataques en la misma fila y columna), se planteó la codificación actual que hace uso del índice de la lista como posición $y$ de la reina (valor unívoco).

\subsubsection{¿Por qué la codificación actual es mejor que las otras?}

Esta codificación es mucho más eficiente que las codificaciones anteriormente propuestas, ya que ocupa mucho menos espacio en memoria (un vector de ints ocupa $K*N$ bits, siendo $K=4$ para una arquitectura estándar de 32-bit o 64-bit, frente a la peor solución anteriormente propuesta, un vector $N*N$ binario, que ocuparía $N*N$ bits).

Además, esta codificación lleva implícitas las restricciones de fila y columna para cada reina. La restricción fila va implícita en la propia estructura de datos (no puede haber dos elementos en la misma posición de la lista), y la restricción columna va implícita en el hecho de que los valores del vector son permutaciones de $N$ (no se repite ningún valor de $x$).

Esto nos elimina automáticamente muchas soluciones inválidas de la población, agilizando el algoritmo y permitiendo encontrar una solución mucho más rápidamente.

\subsection{Función de fitness.}

Se plantean dos funciones de fitness para el problema a tratar:

\begin{enumerate}
    \item En primer lugar, y considerando que no llegamos a posicionar $N$ número de reinas, se considera la función $F=\frac{n}{N} - \frac{b}{n}$, siendo $n$ el número total de reinas posicionadas sobre el tablero frente a $N$ (número ideal de reinas y dimensión del lado del tablero), y $b$ el número de reinas mal posicionadas. Esta función vale 1 cuando todas las reinas están bien posicionadas, y 0 cuando están todas mal posicionadas, o no hay reinas sobre el tablero.
    \item Considerando que, debido a nuestra codificación, no existe la posibilidad de que $n$ sea distinta de $N$ (siempre hay $N$ reinas sobre el tablero, aunque estén mal situadas), se propone la función $F=1-\frac{b}{N}$, que no es más que una substitución de $n=N$ en la función propuesta anteriormente. Esta es la función implementada.
\end{enumerate}

Nuestro algoritmo incorpora también un caché de fitness por individuo, con el objetivo de evitar evaluaciones sobre individuos idénticos. De esta forma, los accesos a caché no se cuentan como evaluaciones, sólo cuando es necesario calcular el fitness del individuo dado.

\subsection{Métodos implementados}

\subsubsection{Selección}

El método de selección aplicado para nuestro problema es una selección por torneo.

Para esta selección tomamos un parámetro $K$ que se corresponde con el tamaño de la muestra de población que tomamos para nuestro torneo. A continuación, evaluamos la muestra y seleccionamos al mejor individuo un número de veces definido por el parámetro $L$ (el número de hijos que queremos conseguir a partir de $L*2$ padres).

Originalmente, se implementa el método de selección sugerido en el libro \emph{An Introduction to Genetic Algorithms} (Melanie, M. 1996), en el cual la selección por torneo ordenaba la muestra de tamaño $K$ por su grado de fitness, y seleccionaba los dos mejores como padres de la nueva población. Por razones de simplificación, se decide que el corte se realiza en $L$, quedando por defecto un tamaño de muestra $K$ y un tamaño de ganadores del torneo de $L$.

Sin embargo, se llegó a la conclusión de que era mejor repetir el proceso de torneo $L$ veces hasta conseguir el número deseado de padres.

El método de selección escogido va acompañado de la política de reemplazo correspondiente (siempre renovando una parte significativa de la población, igual al número de hijos que introducimos en ésta). El tamaño de la población siempre se mantiene constante.

\subsubsection{Cruce}

El cruce que se implementa es una recombinación discreta entre los dos padres con cuidado de no repetir ninguno de los anteriores valores de $N$ 

En el código se implementan tres métodos de cruce:

\begin{itemize}
    \item \textbf{Cruce secuencial constructivo aleatorio}: vamos construyendo el hijo progresivamente (de longitud $0$ a $N$, donde el valor $i$-ésimo del hijo corresponderá con el bit $i$ de uno de los padres, escogido al azar.
    \item \textbf{Cruce secuencial constructivo (SCX)}: parecido al método anterior, este método va construyendo progresivamente el hijo con una pseudo-evaluación a modo de heurística. Para cada par de bits ($p1, p2$) se evalúa su coste (fitness del individuo $F'(I)=F(I)+p$) de ser añadido al hijo, y se coge el bit que mejora el fitness del individuo.

    Ejemplo: 
    
    $p1=[4,3,1,2]$, $p2=[1,2,3,4]$
    
    $h =[1]$ (inicializado al azar) $\rightarrow$ se evalúa $h_1=[1,3]$ y $h_2=[1,2]$. 
    
    Si se considera que $h_1=[1,3]$ tiene mejor fitness que $h_2=[1,2]$, $h=[1,3]$, y así N veces hasta completar el hijo.

    \item \textbf{Cruce ordenado 1 (OC1)}: sean dos padres $p1$ y $p2$, uno de ellos se considera cadena de \emph{corte} y otro cadena de \emph{llenado}. Se selecciona una sub-cadena del primer padre y se inserta en el hijo respetando la posición original. Se llenan los huecos laterales con los valores del otro padre que no están ya en la sub-cadena seleccionada del primero (para no repetir valores).

    Ejemplo:
    $p1=[A,B,C,D,E,F,G,H,I]$, $p2=[a,b,c,d,e,f,g,h,i]$
    
    Sección de corte: $\_ \_ CDEF \_ \_ \_$. Valores de llenado: $h,a,i,b,g$
    
    $h=[h, a, C, D, E, F, i, b, g]$
    
    \textbf{Posibles alternativas}
    
    \subitem Cambiando el orden de inserción del bloque de llenado: $h_2=[b, g, C, D, E, F, h, a, i]$
    
    \subitem Inviertiendo la selección \emph{corte}-\emph{llenado}: $h_3=[H, A, c, d, e, f, I, B, G]$
    
\end{itemize}


\subsubsection{Mutación}

\begin{enumerate}
    \item Primera aproximación: se mutan los dos hijos con probabilidad $p_m$. Aproximación clásica: por cada bit del individuo, se evalúa su probabilidad de mutación, y se cambia el bit (0-1). Al no ser codificación binaria, lo cambiamos por valores 0-N.
    \item Segunda aproximación: con (1) obtenemos resultados repetidos, nuestra codificación es una permutación de columnas (valores 0-N). Por lo tanto, evaluamos la probabilidad del individuo entero de mutar, y si es positiva hacemos un reordenamiento de sus valores (shuffle).
    \item Tercera aproximación: con (2) obtenemos valores demasiado aleatorios con una probabilidad de mutación elevada. Nuestra aproximación esta vez consiste de nuevo en evaluar la probabilidad de mutación bit a bit, y en caso de ser positiva, intercambiando dicho bit con otro bit del individuo de manera aleatoria. De esta forma, en caso de mutar 1 bit, el individuo sólo diferirá del original en 2 bits.
    \item Cuarta aproximación: con (3) se estanca mucho. Queremos mutar el individuo más, introducimos un índice de diversidad. Este índice multiplica la probabilidad de mutación hasta 1, momento en el cual se resetea de nuevo (para evitar demasiada aleatoriedad). Cambiamos también el planteamiento de (3), ahora considera la probabilidad pm para todo el individuo, y en caso positivo hace un solo cambio de un par de bits (swap).
    
\end{enumerate}
\textbf{Nota:}
la probabilidad de mutar depende de N, ya que el número de bits a mutar depende también del tamaño del individuo, así que para hacerlo más constante tomamos la probabilidad de 1/N y la multiplicamos por la probabilidad por individuo.


\subsubsection{Evaluación de la población: posibles soluciones}
En primer lugar, recorremos toda la población evaluando el fitness de cada individuo. En caso de encontrar un individuo con fitness perfecto ($1$), es decir, una solución, se imprime por pantalla la solución, el número de evaluaciones hasta ese momento, así como el número de ciclos.

En caso de no encontrar solución, revisamos igualmente el fitness del mejor individuo de la población para ver si ha mejorado de una generación a otra. En caso contrario, modificamos el índice de diversidad descrito anteriormente.

\subsection{Parametrización}

De Jong's experiments indicated that the best population size was 50–100 individuals, the best single-point crossover rate was about 0.6 per pair of parents, and the best mutation rate was 0.001 per bit - De Jong (1975) mencionado en \emph{An Introduction to Genetic Algorithms} (Melanie, M. 1996) 

Nota:  Grefenstette (1986) noted that, since the GA could be used as an optimization procedure, it could be used to optimize the parameters for another GA! (A similar study was done by Bramlette (1991).) In Grefenstette's experiments, the "meta-level GA" evolved a population of 50 GA parameter sets for the problems in De Jong's test suite. Each individual encoded six GA parameters: population size, crossover rate, mutation rate, generation gap, scaling window (a particular scaling technique that I won't discuss here), and selection strategy (elitist or nonelitist).

Result: These settings were similar to those found by Grefenstette: population size 20–30, crossover rate 0.75–0.95, and mutation rate 0.005–0.01

Parámetros propuestos, e impacto de los mismos en los 
resultados, incluyendo 
gráficas y 
tablas que sean pertinentes

\begin{itemize}
    \setlength\itemsep{0em}
    \item Capas: \textbf{3}.
    \item Momentum: \textbf{0.2455}.
    \item Número de ciclos: \textbf{400}.
    \item El conjunto de datos, con un número reducido de patrones de
    entrada, requiere un modelo con una tasa de aprendizaje alta. Se fijó este
    valor en \textbf{0.61} y sin decaer durante el entrenamiento.
\end{itemize}

La elección de dichos parámetros se basó en una comparativa de los distintos
valores posibles, como podemos ver en la siguiente figura:

\begin{figure}[h]
    \center
    %\includegraphics[width=\textwidth]{graphics}
    \caption{Evolución del acierto en la clasificación según los parámetros escogidos para el entrenamiento}
    \label{}
\end{figure}

\subsection{Resultados}

Resultados obtenidos y 
número de evaluaciones
necesarias

Nota: tiempos de ejecución del algoritmo principal con parámetros por defecto (en ms):
Params: python3 AG\_N\_reinas.py 16 100000 200 4 2 0.001 0.4 0.8

Tiempo init:  3.2100677490234375
Tiempo evaluacion:  1.2519359588623047
Tiempo selección:  0.07486343383789062
Tiempo cruce:  0.1010894775390625
Tiempo mutación:  0.06699562072753906


\newpage


\newpage

\section{Conclusiones, Problemas Encontrados y Opiniones Personales}

Problemas:
estancamiento.

De menor a mayor estancamiento en cruce:
- cruce SCX aleatorio
- cruce SCX no ordenado
- cruce SCX

\section{Anexo}



\newcounter{atm}

\end{document}
